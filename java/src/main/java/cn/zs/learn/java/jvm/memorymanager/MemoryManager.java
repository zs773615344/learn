package cn.zs.learn.java.jvm.memorymanager;

public class MemoryManager {

    /**
     * java运行一个程序会启动一个jvm实例，jvm实例中会有一个java堆、方法区、运行时常量池、
     *  java栈、PC寄存器和本地方法区。一个java程序可以运行多个线程。其中方法区和java堆是所有
     *  线程共享的，针对每个线程会创建一个java栈和一个pc寄存器，栈和寄存器是线程私有的。
     *  栈帧是栈的元素，每一个方法从调用开始到执行完成的过程，就对应一个栈帧在栈里面从入
     *  栈到出栈的过程。栈帧中保存的是该线程中方法调用的状态，包括局部变量表、操作数栈、动态
     *  连接、方法返回地址和一些额外的符加信息（栈帧的局部变量表和操作数栈的大小在编译期决
     *  定）。而pc寄存器会指向即将执行的下一条指令。
     *
     * java堆：堆时用于存储java对象和数组的内存区域。堆的大小在jvm启动时就一次向操作系统申请完成，
     *  可以通过-Xmx和-Xms两个选项来控制大小，Xmx表示堆的最大大小，Xms表示初始大小。一旦分配
     *  完成，堆的大小就将固定，不能在内存不够时再向操作系统申请，同时当内存空闲时也不能将多余
     *  的空间交还给操作系统。java堆是垃圾收集器管理的主要区域。
     *
     * java栈：每个线程创建时jvm都会为它创建一个堆栈，是线程私有的，生命周期和线程相同，堆栈的大小
     *  根据不同的jvm实现而不同，通常在256k～756k之间。可使用-Xss设置栈的大小。栈最小设置为228k
     *
     * 方法区：用于存储已被虚拟机加载的类信息、“常量”、静态变量，jvm只会加载在程序明确使用的类，
     *  可以用-verbose:class查看加载了哪些类。这个区域的内存回收目标主要是针对常量池的回收和
     *  对类型的卸载。
     *  @since jdk1.7 方法区是堆的一部分，有一个别名叫Non-Heap（非堆），属于非堆内存。
     *  也叫永久代（PermGen区），是hotspot虚拟机使用永久代来实现方法区，其他虚拟机没有永久代的概念
     *
     * 运行时常量池：是方法区的一部分，用于存放编译期生成的各种字面量和符号引用(即class文件的常量池部分)，
     *  这部分内容是在类加载后存放在方法区的常量池中的。一般来说，除了保存class文件常量池中描述的符号引用外，
     *  还会把翻译出来的直接引用也存储在常量池中。
     *
     *      class文件常量池中
     *          字面量：字面量比较接近与常量概念，如文本字符串、整数
     *          符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
     *
     *  @since jdk1.8 将方法区迁到本地内存，叫metespace（元空间）,而方法区的静态变量和常量池的字面量
     *  迁移到java heap内存中了。
     *
     * 本地方法栈：是为虚拟机执行本地方法服务。暂不考虑
     *
     * 直接内存：并不是虚拟机运行时数据区的一部分。在nio中引入的Buffer的i/o方式，可以使用native方法
     * 直接分配堆外内存。直接内存的分配不会受到java堆的限制。可以使用-XX:MaxDirctMemorySize,如果不
     * 指定，则默认与java堆的最大值一样。
     *
     *
     *
     *
     *
     *
     *
    */
}
